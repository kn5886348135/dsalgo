概率统计：如何利用朴素贝叶斯算法过滤垃圾短信？
===

&emsp;&emsp;如果你是一名手机应用开发工程师，让你实现一个简单的垃圾短信过滤功能以及骚扰电话拦截功能，该用什么样的数据结构和算法实现呢？

### 算法解析

1. ##### 基于黑名单的过滤器

&emsp;&emsp;可以维护一个骚扰电话号码和垃圾短信发送号码的黑名单。这个黑名单的搜集，有很多途径，比如，可以从一些公开的网站上下载，也可以通过类似“360 骚扰电话拦截”的功能，通过用户自主标记骚扰电话来收集。对于被多个用户标记，并且标记个数超过一定阈值的号码，就可以定义为骚扰电话，并将它加入到的黑名单中。

&emsp;&emsp;如果黑名单中的电话号码不多的话，可以使用散列表、二叉树等动态数据结构来存储，对内存的消耗并不会很大。如果把每个号码看作一个字符串，并且假设平均长度是 16 个字节，那存储 50 万个电话号码，大约需要 10MB 的内存空间。即便是对于手机这样的内存有限的设备来说，这点内存的消耗也是可以接受的。

&emsp;&emsp;但是，如果黑名单中的电话号码很多呢？比如有 500 万个。这个时候，如果再用散列表存储，就需要大约 100MB 的存储空间。为了实现一个拦截功能，耗费用户如此多的手机内存，这显然有点儿不合理。

&emsp;&emsp;布隆过滤器最大的特点就是比较省存储空间，所以，用它来解决这个问题再合适不过了。如果要存储 500 万个手机号码，把位图大小设置为 10 倍数据大小，也就是 5000 万，那也只需要使用 5000 万个二进制位（5000 万 bits），换算成字节，也就是不到 7MB 的存储空间。比起散列表的解决方案，内存的消耗减少了很多。

&emsp;&emsp;实际上，还有一种时间换空间的方法，可以将内存的消耗优化到极致。

&emsp;&emsp;可以把黑名单存储在服务器端上，把过滤和拦截的核心工作，交给服务器端来做。手机端只负责将要检查的号码发送给服务器端，服务器端通过查黑名单，判断这个号码是否应该被拦截，并将结果返回给手机端。

&emsp;&emsp;用这个解决思路完全不需要占用手机内存。不过，有利就有弊。知道，网络通信是比较慢的，所以，网络延迟就会导致处理速度降低。而且，这个方案还有个硬性要求，那就是只有在联网的情况下，才能正常工作。

&emsp;&emsp;布隆过滤器会有判错的概率，如果它把一个重要的电话或者短信，当成垃圾短信或者骚扰电话拦截了，对于用户来说，这是无法接受的。

2. ##### 基于规则的过滤器

&emsp;&emsp;如果某个垃圾短信发送者的号码并不在黑名单中，那这种方法就没办法拦截了。所以，基于黑名单的过滤方式，还不够完善，再继续看一种基于规则的过滤方式。

&emsp;&emsp;对于垃圾短信来说，还可以通过短信的内容，来判断某条短信是否是垃圾短信。预先设定一些规则，如果某条短信符合这些规则，就可以判定它是垃圾短信。实际上，规则可以有很多，比如下面这几个：

* 短信中包含特殊单词（或词语），比如一些非法、淫秽、反动词语等；

* 短信发送号码是群发号码，非正常的手机号码，比如 +60389585；

* 短信中包含回拨的联系方式，比如手机号码、微信、QQ、网页链接等，因为群发短信的号码一般都是无法回拨的；

* 短信格式花哨、内容很长，比如包含各种表情、图片、网页链接等；

* 符合已知垃圾短信的模板。垃圾短信一般都是重复群发，对于已经判定为垃圾短信的短信，可以抽象成模板，将获取到的短信与模板匹配，一旦匹配，就可以判定为垃圾短信。

&emsp;&emsp;如果短信只是满足其中一条规则，就判定为垃圾短信，那会存在比较大的误判的情况。可以综合多条规则进行判断。比如，满足 2 条以上才会被判定为垃圾短信；或者每条规则对应一个不同的得分，满足哪条规则，就累加对应的分数，某条短信的总得分超过某个阈值，才会被判定为垃圾短信。

&emsp;&emsp;只是给出了一些制定规则的思路，具体落实到执行层面，其实还有很大的距离，还有很多细节需要处理。比如，第一条规则中，该如何定义特殊单词；第二条规则中，该如何定义什么样的号码是群发号码等等。

&emsp;&emsp;如果只是自己盘脑袋想，哪些单词属于特殊单词，那势必有比较大的主观性，也很容易漏掉某些单词。实际上，可以基于概率统计的方法，借助计算机强大的计算能力，找出哪些单词最常出现在垃圾短信中，将这些最常出现的单词，作为特殊单词，用来过滤短信。

&emsp;&emsp;不过这种方法的前提是，有大量的样本数据，也就是说，要有大量的短信（比如 1000 万条短信），并且还要求，每条短信都做好了标记，它是垃圾短信还是非垃圾短信。

&emsp;&emsp;对这 1000 万条短信，进行分词处理（借助中文或者英文分词算法），去掉“的、和、是”等没有意义的停用词（Stop words），得到 n 个不同的单词。针对每个单词，统计有多少个垃圾短信出现了这个单词，有多少个非垃圾短信会出现这个单词，进而求出每个单词出现在垃圾短信中的概率，以及出现在非垃圾短信中的概率。如果某个单词出现在垃圾短信中的概率，远大于出现在非垃圾短信中的概率，那就把这个单词作为特殊单词，用来过滤垃圾短信。

<img src="assert/FilterBasedOnRules.jpg" alt="基于规则的过滤器" style="zoom:50%;" />

3. ##### 基于概率统计的过滤器

&emsp;&emsp;基于规则的过滤器，看起来很直观，也很好理解，但是它也有一定的局限性。一方面，这些规则受人的思维方式局限，规则未免太过简单；另一方面，垃圾短信发送者可能会针对规则，精心设计短信，绕过这些规则的拦截。对此，再来看一种更加高级的过滤方式，基于概率统计的过滤方式。

&emsp;&emsp;这种基于概率统计的过滤方式，基础理论是基于朴素贝叶斯算法。

&emsp;&emsp;假设事件 A 是“小明不去上学”，事件 B 是“下雨了”。现在统计了一下过去 10 天的下雨情况和小明上学的情况，作为样本数据。



&emsp;&emsp;来分析一下，这组样本有什么规律。在这 10 天中，有 4 天下雨，所以下雨的概率 P(B)=4/10。10 天中有 3 天，小明没有去上学，所以小明不去上学的概率 P(A)=3/10。在 4 个下雨天中，小明有 2 天没去上学，所以下雨天不去上学的概率 P(A|B)=2/4。在小明没有去上学的 3 天中，有 2 天下雨了，所以小明因为下雨而不上学的概率是 P(B|A)=2/3。实际上，这 4 个概率值之间，有一定的关系，这个关系就是朴素贝叶斯算法，

<img src="assert/NaiveBayesAlgorithm.jpg" alt="朴素贝叶斯算法" style="zoom:50%;" />

&emsp;&emsp;如何利用朴素贝叶斯算法，来做垃圾短信的过滤。

&emsp;&emsp;基于概率统计的过滤器，是基于短信内容来判定是否是垃圾短信。而计算机没办法像人一样理解短信的含义。所以，需要把短信抽象成一组计算机可以理解并且方便计算的特征项，用这一组特征项代替短信本身，来做垃圾短信过滤。

&emsp;&emsp;可以通过分词算法，把一个短信分割成 n 个单词。这 n 个单词就是一组特征项，全权代表这个短信。因此，判定一个短信是否是垃圾短信这样一个问题，就变成了，判定同时包含这几个单词的短信是否是垃圾短信。

&emsp;&emsp;不过，这里并不像基于规则的过滤器那样，非黑即白，一个短信要么被判定为垃圾短信、要么被判定为非垃圾短息。使用概率，来表征一个短信是垃圾短信的可信程度。如果用公式将这个概率表示出来，就是下面这个样子：

<img src="assert/NaiveBayesFormulaA.jpg" alt="朴素贝叶斯公式" style="zoom:50%;" />

&emsp;&emsp;尽管有大量的短信样本，但是没法通过样本数据统计得到这个概率。为什么不可以呢？你可能会说，我只需要统计同时包含 $W~1~$，$W~2~$，$W~3~$，…，$W~n~$ 这 n 个单词的短信有多少个（假设有 x 个），然后看这里面属于垃圾短信的有几个（假设有 y 个），那包含 $W~1~$，$W~2~$，$W~3~$，…，$W~n~$ 这 n 个单词的短信是垃圾短信的概率就是 y/x。

&emsp;&emsp;理想很丰满，但现实往往很骨感。你忽视了非常重要的一点，那就是样本的数量再大，毕竟也是有限的，样本中不会有太多同时包含 $W~1~$，$W~2~$，$W~3~$，…，$W~n~$ 的短信的，甚至很多时候，样本中根本不存在这样的短信。没有样本，也就无法计算概率。所以这样的推理方式虽然正确，但是实践中并不好用。

&emsp;&emsp;这个时候，朴素贝叶斯公式就可以派上用场了。通过朴素贝叶斯公式，将这个概率的求解，分解为其他三个概率的求解。你可以看我画的图。那转化之后的三个概率是否可以通过样本统计得到呢？

<img src="assert/NaiveBayesFormulaB.jpg" alt="朴素贝叶斯公式" style="zoom:50%;" />

&emsp;&emsp;P（$W~1~$，$W~2~$，$W~3~$，…，$W~n~$ 同时出现在一条短信中 | 短信是垃圾短信）这个概率照样无法通过样本来统计得到。但是可以基于下面这条著名的概率规则来计算。

独立事件发生的概率计算公式：P(A*B) = P(A)*P(B)

&emsp;&emsp;如果事件 A 和事件 B 是独立事件，两者的发生没有相关性，事件 A 发生的概率 P(A) 等于 p1，事件 B 发生的概率 P(B) 等于 p2，那两个同时发生的概率 P(A*B) 就等于 P(A)*P(B)。

&emsp;&emsp;基于这条独立事件发生概率的计算公式，可以把P（$W~1~$，$W~2~$，$W~3~$，…，$W~n~$ 同时出现在一条短信中 | 短信是垃圾短信）分解为下面这个公式：

<img src="assert/NaiveBayesFormulaC.jpg" alt="朴素贝叶斯公式" style="zoom:50%;" />

&emsp;&emsp;其中，P（Wi 出现在短信中 | 短信是垃圾短信）表示垃圾短信中包含 $W~i~$ 这个单词的概率有多大。这个概率值通过统计样本很容易就能获得。假设垃圾短信有 y 个，其中包含 Wi 的有 x 个，那这个概率值就等于 x/y。

&emsp;&emsp;P（$W~1~$，$W~2~$，$W~3~$，…，$W~n~$ 同时出现在一条短信中 | 短信是垃圾短信）这个概率值，就计算出来了，再来看下剩下两个。

&emsp;&emsp;P（短信是垃圾短信）表示短信是垃圾短信的概率，这个很容易得到。把样本中垃圾短信的个数除以总样本短信个数，就是短信是垃圾短信的概率。

&emsp;&emsp;不过，P（$W~1~$，$W~2~$，$W~3~$，…，$W~n~$同时出现在一条短信中）这个概率还是不好通过样本统计得到，原因前面说过了，样本空间有限。不过，没必要非得计算这一部分的概率值。为什么这么说呢？

&emsp;&emsp;实际上，可以分别计算同时包含 W1，W2，W3，…，Wn 这 n 个单词的短信，是垃圾短信和非垃圾短信的概率。假设它们分别是 p1 和 p2。并不需要单纯地基于 p1 值的大小来判断是否是垃圾短信，而是通过对比 p1 和 p2 值的大小，来判断一条短信是否是垃圾短信。更细化一点讲，那就是，如果 p1 是 p2 的很多倍（比如 10 倍），才确信这条短信是垃圾短信。

<img src="assert/NaiveBayesFormulaD.jpg" alt="朴素贝叶斯公式" style="zoom:50%;" />

&emsp;&emsp;基于这两个概率的倍数来判断是否是垃圾短信的方法，就可以不用计算 P（$W~1~$，$W~2~$，$W~3~$，…，$W~n~$ 同时出现在一条短信中）这一部分的值了，因为计算 p1 与 p2 的时候，都会包含这个概率值的计算，所以在求解 p1 和 p2 倍数（p1/p2）的时候，也就不需要这个值。

#### 总结引申

&emsp;&emsp;黑名单、规则、概率统计三种垃圾短信的过滤方法，还可以应用到很多类似的过滤、拦截的领域，比如垃圾邮件的过滤等等。

&emsp;&emsp;黑名单过滤的时候布隆过滤器可能会存在误判情况，可能会导致用户投诉。实际上，可以结合三种不同的过滤方式的结果，对同一个短信处理，如果三者都表明这个短信是垃圾短信，才把它当作垃圾短信拦截过滤，这样就会更精准。

&emsp;&emsp;当然，在实际的工程中，还需要结合具体的场景，以及大量的实验，不断去调整策略，权衡垃圾短信判定的准确率（是否会把不是垃圾的短信错判为垃圾短信）和召回率（是否能把所有的垃圾短信都找到），来实现的需求。

#### 课后思考

&emsp;&emsp;关于垃圾短信过滤和骚扰电话的拦截，可以一块儿头脑风暴一下，看看你还有没有其他方法呢？




对于短信文本，机器学习尤其是 NLP 方向的很多算法可用于 anti-spam。文本分类任务，特征工程做得稍用心的话，判别式模型（典型如 logistic regression）的效果通常好于生成式模型（典型如 naive-bayes）。

对于电话号码数字，感觉用正则或定时拉取黑名单比 ml 模型简单可靠。








我觉得这种分类过滤，最好的可能是机器学习，通过大量的垃圾短信样本来训练特征，最后可以达到过滤短信和邮件的目的，而且这种方法应该效果更好，至于电话拦截，实际上就是电话号码黑名单的问题，我觉得用布隆过滤器可以满足通用场景，一般实际场景中，对于这种电话是提示谨慎接听，但是可以本地和云端结合处理，解决部分的误报问题，当判断是黑名单的时候再去云端查，确认是否是真的黑名单。这样用布隆过滤器+云端也是一种方式






黑名单过滤法基于经验判断，难以确保及时性。基于内容规则的过滤法容易被针对，而且动态调整规则的成本较高。基于朴素贝叶斯算法的内容概率过滤法，既可以确保及时性，又能够较好的基于实际情况的变化而变化，具备初步智能特性。因为贝叶斯方法是基于先验判断，然后根据现实反馈动态调整判断的算法。

当绝对值不好计算时，可以结合场景需要，合理使用相对值代替绝对值，以简化计算难度、消除无法计算的因子。







为啥P(W1W2...Wn|垃圾短信)是独立事件，能够拆成乘积，而P(W1W2...Wn)不是独立事件？
作者回复: 也是也是。








其实这个问题就是个分类预测问题，传统的机器学习方法中的分类预测算法都可以用








请问，基于黑名单的过滤方式，用布隆过滤器只能存储Bool值，即是否存储，但是还要实现“标记次数来判断是否达到阈值”，就需要额外的散列表了，需要的内存空间依然很大，方案上还不如直接用散列表来的更好吧？

作者回复: 你说的这是一种情况，大部分情况，都不会命中，也就说，都不是骚扰电话。







1.为啥叫naive：因为假设了条件分布中各个feature是独立出现的，feature之间啥关系没有！所以很naive，很朴素，很“傻”，但是效果真的不一定差，而且在没开发出更好的模型之前直接进行统计计算就能得出结果，且可以做成online的，怎么看都不亏啊（反正你也得用统计数据做其他的事，顺道做了呗老弟）！

2.如果概率为0了怎么办！可以使用laplacian smoothing，简单的来说就是在分子分母上面加数来保证不会有0的出现。直接使用很小的数是可以的（遵循频率学派频率为大），但更精确的在分母分子上加什么，这个其实是与贝叶斯学派所认为的先验分布有关，就是在不看sample时，的先验知识对这种情况的估计是多少（比如我在不统计工科学校男女比例的时候就有了一定的先验知识：7:1，之后我再统计其实是对我的先验估计的一种调整）。







https://www.jianshu.com/p/5cf3a155b2f0
找到另外一个相亲的例子






高频点击判断为骚扰短信，中奖，打钱，送东西









P（W1,W2...Wn同时出现在一条短信中） = P（W1出现在短信中） * P（W2出现在短信中） *....* P（Wn出现在短信中）这样计算应该就可以吧










有一问题：

短信中出现的单词w1、w2、…、wn应该不是独立事件吧。很多输入法也是依据用户前面输入的单词来推荐后面用户可能会想输入的单词的。这个应该就能说明单词输入之间不应该是独立事件的。

就算为了解决问题方便，假设事件为独立事件，那么

P(w1、w2、…、wn同时出现在短信中)，这个概率是可以拆分成P(w1)、P(w2)、…、P(wn)相乘计算出来的。也就没有后面那些步骤了。

（btw后面这个思想确实很智慧）








上一节讲了，布隆过滤器最大的特点就是比较省存储空间，所以，用它来解决这个问题再合适不过了。如果要存储 500 万个手机号码，把位图大小设置为 10 倍数据大小，也就是 5000 万，那也只需要使用 5000 万个二进制位（5000 万 bits），换算成字节，也就是不到 7MB 的存储空间。比起散列表的解决方案，内存的消耗减少了很多。

这段话中：对于需要使用的内存空间有疑问，按照上一节的处理方式，把手机号码转换为整数，使用的内存空间应该是整数的范围 * 10 bits, 而不是手机号的数量 * 10 bits? 或者，这里不把手机号码转化为整数，用其他的哈希方法，把这500w个手机号映射到[0, 500W)这个区间内？
作者回复: 布隆过滤器本身就是解决位图消耗空间比较多的问题。位图的大小是数据的范围。而布隆过滤器的大小应该是小于位图大小的，所以肯定就是数据的范围了。







请问怎么确定分词后的哪些词是W，怎么选择。
作者回复: 去掉无意义的“的”“是”等词，都可以作为w






前段时间刚看概率论与数理统计，看了2/3，这么经典的公式现在居然忘完了……








请问具体要如何用位图存储手机号码呢？之前的例子是存储数字，可以直接使用数字的值作为下标。那么这里也要用手机号作为下标吗？还是要再做一次hash处理呢？会需要额外维护手机号与下表的hashmap吗？






P（ Wi出现在短信中 | 短信是垃圾短信）表示垃圾短信中包含 Wi这个单词的概率有多大。

如果wi出现的概率是0怎么办，连乘导致结果是0了？






打算入行NLP的学员，听了这个比较亲切，想多了解一些NLP领域的算法






朴素贝叶斯模型的一个基本假设是条件独立性，即假定w1, w2, ..., wn之间相互独立。这是一个较强的假设，正是这一假设，使朴素贝叶斯的学习与预测大为简化，且易于实现，其缺点是分类的准确率不一定高。