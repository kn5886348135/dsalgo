为什么插入排序比冒泡排序更受欢迎
===

&emsp;&emsp;最经典的、最常用的排序算法有冒泡排序、插入排序、选择排序、归并排序、快速排序、计数排序、基数排序、桶排序。按照时间复杂度把它们分成了三类。还有一些比较不常见的排序算法，比如猴子排序、睡眠排序、面条排序等。

<img src="assert/Sort.jpg" alt="排序算法" style="zoom:50%;" />

&emsp;&emsp;插入排序和冒泡排序的时间复杂度相同，都是 O(n^2^)，在实际的软件开发里，为什么我们更倾向于使用插入排序算法而不是冒泡排序算法呢？

##### 如何分析一个“排序算法”？

&emsp;&emsp;对于排序算法执行效率的分析，我们一般会从这几个方面来衡量

1. **最好情况、最坏情况、平均情况时间复杂度**
&emsp;&emsp;我们在分析排序算法的时间复杂度时，要分别给出最好情况、最坏情况、平均情况下的时间复杂度。除此之外，你还要说出最好、最坏时间复杂度对应的要排序的原始数据是什么样的。
为什么要区分这三种时间复杂度呢？第一，有些排序算法会区分，为了好对比，所以我们最好都做一下区分。第二，对于要排序的数据，有的接近有序，有的完全无序。有序度不同的数据，对于排序的执行时间肯定是有影响的，我们要知道排序算法在不同数据下的性能表现。

2. **时间复杂度的系数、常数 、低阶**
&emsp;&emsp;我们知道，时间复杂度反应的是数据规模 n 很大的时候的一个增长趋势，所以它表示的时候会忽略系数、常数、低阶。但是实际的软件开发中，我们排序的可能是 10 个、100 个、1000 个这样规模很小的数据，所以，在对同一阶时间复杂度的排序算法性能对比的时候，我们就要把系数、常数、低阶也考虑进来。

3. **比较次数和交换（或移动）次数**
&emsp;&emsp;基于比较的排序算法的执行过程，会涉及两种操作，一种是元素比较大小，另一种是元素交换或移动。所以，如果我们在分析排序算法的执行效率的时候，应该把比较次数和交换（或移动）次数也考虑进去。

##### 排序算法的内存消耗

&emsp;&emsp;算法的内存消耗可以通过空间复杂度来衡量，排序算法也不例外。不过，针对排序算法的空间复杂度，我们还引入了一个新的概念，**原地排序**（Sorted in place）。原地排序算法，就是特指空间复杂度是 O(1) 的排序算法。我们今天讲的三种排序算法，都是原地排序算法。

##### 排序算法的稳定性

&emsp;&emsp;仅仅用执行效率和内存消耗来衡量排序算法的好坏是不够的。针对排序算法，我们还有一个重要的度量指标，**稳定性**。这个概念是说，如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。

&emsp;&emsp;比如我们有一组数据 2，9，3，4，8，3，按照大小排序之后就是 2，3，3，4，8，9。

&emsp;&emsp;这组数据里有两个 3。经过某种排序算法排序之后，如果两个 3 的前后顺序没有改变，那我们就把这种排序算法叫作**稳定的排序算法**；如果前后顺序发生变化，那对应的排序算法就叫作**不稳定的排序算法**。

&emsp;&emsp;为什么要考察排序算法的稳定性呢？

&emsp;&emsp;很多数据结构和算法课程，在讲排序的时候，都是用整数来举例，但在真正软件开发中，我们要排序的往往不是单纯的整数，而是一组对象，我们需要按照对象的某个 key 来排序。

&emsp;&emsp;比如说，我们现在要给电商交易系统中的“订单”排序。订单有两个属性，一个是下单时间，另一个是订单金额。如果我们现在有 10 万条订单数据，我们希望按照金额从小到大对订单数据排序。对于金额相同的订单，我们希望按照下单时间从早到晚有序。

&emsp;&emsp;最先想到的方法是：我们先按照金额对订单数据进行排序，然后，再遍历排序之后的订单数据，对于每个金额相同的小区间再按照下单时间排序。这种排序思路理解起来不难，但是实现起来会很复杂。

&emsp;&emsp;借助稳定排序算法，这个问题可以非常简洁地解决。解决思路是这样的：我们先按照下单时间给订单排序，注意是按照下单时间，不是金额。排序完成之后，我们用稳定排序算法，按照订单金额重新排序。两遍排序之后，我们得到的订单数据就是按照金额从小到大排序，金额相同的订单按照下单时间从早到晚排序的。

&emsp;&emsp;**稳定排序算法可以保持金额相同的两个对象，在排序之后的前后顺序不变**。第一次排序之后，所有的订单按照下单时间从早到晚有序了。在第二次排序中，我们用的是稳定的排序算法，所以经过第二次排序之后，相同金额的订单仍然保持下单时间从早到晚有序。

<img src="assert/StableSortingAlgorithm.jpg" alt="稳定排序算法" style="zoom:50%;" />

##### 冒泡排序（Bubble Sort）

&emsp;&emsp;冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作。

<img src="assert/BubbleSorta.jpg" alt="冒泡排序" style="zoom:50%;" />

&emsp;&emsp;可以看出，经过一次冒泡操作之后，6 这个元素已经存储在正确的位置上。要想完成所有数据的排序，我们只要进行 6 次这样的冒泡操作就行了。

<img src="assert/BubbleSortb.jpg" alt="冒泡排序" style="zoom:50%;" />

&emsp;&emsp;实际上，刚讲的冒泡过程还可以优化。当某次冒泡操作已经没有数据交换时，说明已经达到完全有序，不用再继续执行后续的冒泡操作。我这里还有另外一个例子，这里面给 6 个元素排序，只需要 4 次冒泡操作就可以了。

<img src="assert/BubbleSortc.jpg" alt="冒泡排序" style="zoom:50%;" />

&emsp;&emsp;冒泡排序算法的代码
```Java
// 冒泡排序，a 表示数组，n 表示数组大小
public void bubbleSort(int[] a, int n) {
  if (n <= 1) return;
 
 for (int i = 0; i < n; ++i) {
    // 提前退出冒泡循环的标志位
    boolean flag = false;
    for (int j = 0; j < n - i - 1; ++j) {
      if (a[j] > a[j+1]) { // 交换
        int tmp = a[j];
        a[j] = a[j+1];
        a[j+1] = tmp;
        flag = true;  // 表示有数据交换      
      }
    }
    if (!flag) break;  // 没有数据交换，提前退出
  }
}
```
&emsp;&emsp;**三个问题**

1. 第一，冒泡排序是原地排序算法吗？
冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以它的空间复杂度为 O(1)，是一个原地排序算法。

2. 第二，冒泡排序是稳定的排序算法吗？
在冒泡排序中，只有交换才可以改变两个元素的前后顺序。为了保证冒泡排序算法的稳定性，当有相邻的两个元素大小相等的时候，我们不做交换，相同大小的数据在排序前后不会改变顺序，所以冒泡排序是稳定的排序算法。

3. 第三，冒泡排序的时间复杂度是多少？
最好情况下，要排序的数据已经是有序的了，我们只需要进行一次冒泡操作，就可以结束了，所以最好情况时间复杂度是 O(n)。而最坏的情况是，要排序的数据刚好是倒序排列的，我们需要进行 n 次冒泡操作，所以最坏情况时间复杂度为 O(n^2^)。

<img src="assert/TimeComplexityOfBubbleSort.jpg" alt="冒泡排序的时间复杂度" style="zoom:50%;" />

&emsp;&emsp;最好、最坏情况下的时间复杂度很容易分析，平均时间复杂度就是加权平均期望时间复杂度，分析的时候要结合概率论的知识。

&emsp;&emsp;对于包含 n 个数据的数组，这 n 个数据就有$n!$种排列方式。不同的排列方式，冒泡排序执行的时间肯定是不同的。比如我们前面举的那两个例子，其中一个要进行 6 次冒泡，而另一个只需要 4 次。如果用概率论方法定量分析平均时间复杂度，涉及的数学推理和计算就会很复杂。我这里还有一种思路，通过“**有序度**”和“**逆序度**”这两个概念来进行分析。

&emsp;&emsp;有序度是数组中具有有序关系的元素对的个数。有序元素对用数学表达式表示就是这样：

&emsp;&emsp;有序元素对：a[i] $<=$ a[j], 如果 i $<$ j。


&emsp;&emsp;同理，对于一个倒序排列的数组，比如 6，5，4，3，2，1，有序度是 0；对于一个完全有序的数组，比如 1，2，3，4，5，6，有序度就是n*(n-1)/2，也就是 15。我们把这种完全有序的数组的有序度叫作**满有序度**。

&emsp;&emsp;逆序度的定义正好跟有序度相反（默认从小到大为有序）。

&emsp;&emsp;逆序元素对：a[i] $>$ a[j], 如果 i $<$ j。

&emsp;&emsp;关于这三个概念，我们还可以得到一个公式：逆序度 = 满有序度 - 有序度。我们排序的过程就是一种增加有序度，减少逆序度的过程，最后达到满有序度，就说明排序完成了。

&emsp;&emsp;我还是拿前面举的那个冒泡排序的例子来说明。要排序的数组的初始状态是 4，5，6，3，2，1 ，其中，有序元素对有 (4，5) (4，6)(5，6)，所以有序度是 3。n=6，所以排序完成之后终态的满有序度为 n*(n-1)/2=15。

<img src="assert/OrderDegreeOfBubbleSort.jpg" alt="冒泡排序的有序度" style="zoom:50%;" />

&emsp;&emsp;冒泡排序包含两个操作原子，**比较**和**交换**。每交换一次，有序度就加 1。不管算法怎么改进，交换次数总是确定的，即为逆序度，也就是n*(n-1)/2–初始有序度。此例中就是 15–3=12，要进行 12 次交换操作。

&emsp;&emsp;对于包含 n 个数据的数组进行冒泡排序，平均交换次数是多少呢？最坏情况下，初始状态的有序度是 0，所以要进行 n$*$(n-1)/2 次交换。最好情况下，初始状态的有序度是 n$*$(n-1)/2，就不需要进行交换。我们可以取个中间值 n$*$(n-1)/4，来表示初始有序度既不是很高也不是很低的平均情况。

&emsp;&emsp;换句话说，平均情况下，需要 n$*$(n-1)/4 次交换操作，比较操作肯定要比交换操作多，而复杂度的上限是 O(n2)，所以平均情况下的时间复杂度就是 O(n2)。

&emsp;&emsp;这个平均时间复杂度推导过程其实并不严格，但是很多时候很实用，毕竟概率论的定量分析太复杂，不太好用。

###插入排序（Insertion Sort）
&emsp;&emsp;一个有序的数组，我们往里面添加一个新的数据后，我们只要遍历数组，找到数据应该插入的位置将其插入即可保持数据有序。

<img src="assert/InsertionSorta.jpg" alt="插入排序" style="zoom:50%;" />

&emsp;&emsp;这是一个动态排序的过程，即动态地往有序集合中添加数据，我们可以通过这种方法保持集合中的数据一直有序。而对于一组静态数据，我们也可以借鉴上面讲的插入方法，来进行排序，于是就有了插入排序算法。

&emsp;首先，我们将数组中的数据分为两个区间，**已排序区间**和**未排序区间**。初始已排序区间只有一个元素，就是数组的第一个元素。插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。重复这个过程，直到未排序区间中元素为空，算法结束。

如图所示，要排序的数据是 4，5，6，1，3，2，其中左侧为已排序区间，右侧是未排序区间。

<img src="assert/InsertionSortb.jpg" alt="插入排序" style="zoom:50%;" />

&emsp;&emsp;插入排序也包含两种操作，一种是**元素的比较**，一种是**元素的移动**。当我们需要将一个数据 a 插入到已排序区间时，需要拿 a 与已排序区间的元素依次比较大小，找到合适的插入位置。找到插入点之后，我们还需要将插入点之后的元素顺序往后移动一位，这样才能腾出位置给元素 a 插入。

&emsp;&emsp;对于不同的查找插入点方法（从头到尾、从尾到头），元素的比较次数是有区别的。但对于一个给定的初始序列，移动操作的次数总是固定的，就等于逆序度。

&emsp;&emsp;为什么说移动次数就等于逆序度呢？我拿刚才的例子画了一个图表，你一看就明白了。满有序度是 n*(n-1)/2=15，初始序列的有序度是 5，所以逆序度是 10。插入排序中，数据移动的个数总和也等于 10$=$3$+$3$+$4。

<img src="assert/OrderDegradeOfInsertionSort.jpg" alt="插入排序有序度" style="zoom:50%;" />

```Java
// 插入排序，a 表示数组，n 表示数组大小
public void insertionSort(int[] a, int n) {
  if (n <= 1) return;
 
  for (int i = 1; i < n; ++i) {
    int value = a[i];
    int j = i - 1;
    // 查找插入的位置
    for (; j >= 0; --j) {
      if (a[j] > value) {
        a[j+1] = a[j];  // 数据移动
      } else {
        break;
      }
    }
    a[j+1] = value; // 插入数据
  }
}
```

###三个问题

1. 第一，插入排序是原地排序算法吗？
从实现过程可以很明显地看出，插入排序算法的运行并不需要额外的存储空间，所以空间复杂度是 O(1)，也就是说，这是一个原地排序算法。

2. 第二，插入排序是稳定的排序算法吗？
在插入排序中，对于值相同的元素，我们可以选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，所以插入排序是稳定的排序算法。

3. 第三，插入排序的时间复杂度是多少？
如果要排序的数据已经是有序的，我们并不需要搬移任何数据。如果我们从尾到头在有序数据组里面查找插入位置，每次只需要比较一个数据就能确定插入的位置。所以这种情况下，最好是时间复杂度为 O(n)。注意，这里是从尾到头遍历已经有序的数据。
如果数组是倒序的，每次插入都相当于在数组的第一个位置插入新的数据，所以需要移动大量的数据，所以最坏情况时间复杂度为 O(n^2^)。
数组中插入一个数据的平均时间复杂度是 O(n)。所以，对于插入排序来说，每次插入操作都相当于在数组中插入一个数据，循环执行 n 次插入操作，所以平均时间复杂度为 O(n^2^)。

###选择排序（Selection Sort）
&emsp;&emsp;选择排序算法的实现思路有点类似插入排序，也分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。

<img src="assert/SelectionSort.jpg" alt="选择排序" style="zoom:50%;" />

###三个问题

1. 选择排序空间复杂度为 O(1)，是一种原地排序算法。
2. 选择排序的最好情况时间复杂度、最坏情况和平均情况时间复杂度都为 O(n^2^)。
3. 选择排序是一种不稳定的排序算法。选择排序每次都要找剩余未排序元素中的最小值，并和前面的元素交换位置，这样破坏了稳定性。

###解答开篇
&emsp;&emsp;冒泡排序和插入排序的时间复杂度都是 O(n^2^)，都是原地排序算法，为什么插入排序要比冒泡排序更受欢迎呢？

&emsp;&emsp;冒泡排序和插入排序不管怎么优化，元素交换的次数是一个固定值，是原始数据的逆序度。但是，从代码实现上来看，冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要 3 个赋值操作，而插入排序只需要 1 个。我们来看这段操作：

&emsp;&emsp;冒泡排序中数据的交换操作：
```Java
if (a[j] > a[j+1]) { // 交换
   int tmp = a[j];
   a[j] = a[j+1];
   a[j+1] = tmp;
   flag = true;
}
```

&emsp;&emsp;插入排序中数据的移动操作：
```Java
if (a[j] > value) {
  a[j+1] = a[j];  // 数据移动
} else {
  break;
}
```

&emsp;&emsp;我们把执行一个赋值语句的时间粗略地计为单位时间（unit_time），然后分别用冒泡排序和插入排序对同一个逆序度是 K 的数组进行排序。用冒泡排序，需要 K 次交换操作，每次需要 3 个赋值语句，所以交换操作总耗时就是 3$*$K 单位时间。而插入排序中数据移动操作只需要 K 个单位时间。

&emsp;&emsp;这个只是我们非常理论的分析，为了实验，针对上面的冒泡排序和插入排序的 Java 代码，我写了一个性能对比测试程序，随机生成 10000 个数组，每个数组中包含 200 个数据，然后在我的机器上分别用冒泡和插入排序算法来排序，冒泡排序算法大约 700ms 才能执行完成，而插入排序只需要 100ms 左右就能搞定！

&emsp;&emsp;所以，虽然冒泡排序和插入排序在时间复杂度上是一样的，都是 O(n2)，但是如果我们希望把性能优化做到极致，那肯定首选插入排序。插入排序的算法思路也有很大的优化空间，我们只是讲了最基础的一种。如果你对插入排序的优化感兴趣，可以自行学习一下[希尔排序](https://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F)。

###内容小结
&emsp;&emsp;要想分析、评价一个排序算法，需要从执行效率、内存消耗和稳定性三个方面来看。三种时间复杂度是 O(n^2^) 的排序算法，冒泡排序、插入排序、选择排序。

<img src="assert/CompareBetweenBubbleInsertionSelectionSort.jpg" alt="冒泡排序、插入排序、选择排序的比较" style="zoom:50%;" />

&emsp;&emsp;这三种时间复杂度为 O(n^2^) 的排序算法中，冒泡排序、选择排序，可能就纯粹停留在理论的层面了，学习的目的也只是为了开拓思维，实际开发中应用并不多，但是插入排序还是挺有用的。有些编程语言中的排序函数的实现原理会用到插入排序算法。

&emsp;&emsp;这三种排序算法，实现代码都非常简单，对于小规模数据的排序，用起来非常高效。但是在大规模数据排序的时候，这个时间复杂度还是稍微有点高，所以我们更倾向于用时间复杂度为 O(nlogn) 的排序算法。

###课后思考
&emsp;&emsp;特定算法是依赖特定的数据结构的。我们今天讲的几种排序算法，都是基于数组实现的。如果数据存储在链表中，这三种排序算法还能工作吗？如果能，那相应的时间、空间复杂度又是多少呢？

有个前提，是否允许修改链表的节点value值，还是只能改变节点的位置。一般而言，考虑只能改变节点位置，冒泡排序相比于数组实现，比较次数一致，但交换时操作更复杂；插入排序，比较次数一致，不需要再有后移操作，找到位置后可以直接插入，但排序完毕后可能需要倒置链表；选择排序比较次数一致，交换操作同样比较麻烦。综上，时间复杂度和空间复杂度并无明显变化，若追求极致性能，冒泡排序的时间复杂度系数会变大，插入排序系数会减小，选择排序无明显变化。
三种排序算法不涉及随机读取，所以链表是可以实现的

[算法过程动态图](https://visualgo.net/)

总结

一、排序方法与复杂度归类
（1）几种最经典、最常用的排序方法：冒泡排序、插入排序、选择排序、快速排序、归并排序、计数排序、基数排序、桶排序。
（2）复杂度归类
冒泡排序、插入排序、选择排序  O(n^2^)   基于比较      希尔排序
快速排序、归并排序           O(nlogn)  基于比较
计数排序、基数排序、桶排序    O(n)      不基于比较

[十大经典排序算法](https://mp.weixin.qq.com/s/HQg3BzzQfJXcWyltsgOfCQ)



| 算法     | 最好         | 最坏       | 平均    | 均摊 | 空间 | 原地 | 稳定 | 比较 |
| -------- | ------------ | ---------- | ------- | ---- | ---- | ---- | ---- | ---- |
| 冒泡     | O(n)         | O(n^2^)    | O(n^2^) |      |      | 是   | 是   | 是   |
| 插入     | O(n)         | O(n^2^)    | O(n^2^) |      |      | 是   | 是   | 是   |
| 选择     | O(n^2^)      | O(n^2^)    | O(n^2^) |      |      | 是   | 否   | 是   |
| 希尔     |              |            |         |      |      |      |      |      |
| 快排     | O(n$log{n}$) |            |         |      |      |      |      | 是   |
| 归并     | O(n$log{n}$) |            |         |      |      | 否   |      | 是   |
| 计数     | O(n)         |            |         |      |      |      |      | 否   |
| 基数     | O(n)         |            |         |      |      |      |      | 否   |
| 桶排序   | O(n)         | O(n$logn$) |         |      |      |      |      | 否   |
| 猴子排序 |              |            |         |      |      |      |      |      |
| 睡眠排序 |              |            |         |      |      |      |      |      |
| 面条排序 |              |            |         |      |      |      |      |      |





对于老师所提课后题，觉得应该有个前提，是否允许修改链表的节点value值，还是只能改变节点的位置。一般而言，考虑只能改变节点位置，冒泡排序相比于数组实现，比较次数一致，但交换时操作更复杂；插入排序，比较次数一致，不需要再有后移操作，找到位置后可以直接插入，但排序完毕后可能需要倒置链表；选择排序比较次数一致，交换操作同样比较麻烦。综上，时间复杂度和空间复杂度并无明显变化，若追求极致性能，冒泡排序的时间复杂度系数会变大，插入排序系数会减小，选择排序无明显变化。



算法过程动态图，可以看看这个https://visualgo.net/





https://mp.weixin.qq.com/s/HQg3BzzQfJXcWyltsgOfCQ

这里面的图解排序算法，很形象。java实现的代码





a[j+1] = value; // 插入数据，这条语句弄了好久才明白，一直以为 j的值最小为0，那么a[j+1]最小就是a[1]，不过这样赋值逻辑上就有问题，后来debug了一下，发现j是可以为-1的，a[j+1]最小为a[0]，这样逻辑上就通了，果然多敲代码才能弄明白勒





三种排序算法不涉及随机读取，所以链表是可以实现的，而且时间复杂度空间空间复杂度和数组一样，O(n*n),O(1).


冒泡排序：https://github.com/lipeng1991/testdemo/blob/master/40_bubble_sort.py
插入排序：https://github.com/lipeng1991/testdemo/blob/master/41_insert_sort.py
选择排序： https://github.com/lipeng1991/testdemo/blob/master/42_select_sort.py





冒泡、插入、选择排序都有一个共同点，将待排序数列分为已排序和未排序两部分。在未排序的部分中查找一个最值，放到已排序数列的恰当位置。

具体到代码层面，外层循环的变量用于分割已排序和未排序数，内层循环的变量用于在未排序数中查找。从思路上看，这三种算法其实是一样的，所以时间复杂度也相同。



代码实现：
/**
 \* 冒泡排序
 \* @param a 待排序数组
 \* @param n 数组长度
 */
public static void bubbleSort(int[] a, int n) {
    if(n<=0) return ;
  for (int i = 0; i < n; i++) {
    //标记一次冒泡是否存在数据交换，若存在，则改为true
    boolean tag = false;
    for (int j = 0; j < n-1-i; j++) {
      if(a[j] > a[j+1]){
        int temp = a[j];
        a[j] = a[j+1];
        a[j+1] = temp;
        tag = true;
      }
    }
    //若本次冒泡操作未发生数据交换，则终止冒泡操作
    if (tag == false) break;
  }
}

/**
 \* 插入排序
 \* @param a 待排序数组
 \* @param n 表示数组大小
 */
public static void insertSort(int[] a, int n) {
    if(n<=1) return;
    for(int i=1;i<n;i++){
      int value=a[i];
      int j=i-1;
      //找到插入位置
      for(;j>0;j--){
      if(a[j]>value){
         a[j+1]=a[j];//移动数据
      } else {
         break;
      }
    }
    a[j+1]=value;//插入数据
    }
}

/**
 \* 选择排序
 \* @param a 待排序数组
 \* @param n 数组长度
 */
public static void selectSort(int[] a, int n) {
  if(n<=0) return;
    for(int i=0;i<n;i++){
       int min=i;
       for(int j=i;j<n;j++){
         if(a[j] < a[min]) min=j;
       }
       if(min != i){
         int temp=a[i];
         a[i]=a[min];
         a[min]=temp;
       }
    }
}
