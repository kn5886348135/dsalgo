字符串匹配基础（中）：如何实现文本编辑器中的查找功能？
===

&emsp;&emsp;文本编辑器中的查找替换功能，比如，在 Word 中把一个单词统一替换成另一个，用的就是这个功能。 BF 算法和 RK 算法，可以实现这个功能，但是在某些极端情况下，BF 算法性能会退化的比较严重，而 RK 算法需要用到哈希算法，而设计一个可以应对各种类型字符的哈希算法并不简单。

&emsp;&emsp;对于工业级的软件开发来说，希望算法尽可能的高效，并且在极端情况下，性能也不要退化的太严重。那么，对于查找功能是重要功能的软件来说，比如一些文本编辑器，它们的查找功能都是用哪种算法来实现的呢？有没有比 BF 算法和 RK 算法更加高效的字符串匹配算法呢？

&emsp;&emsp; BM（Boyer-Moore）算法，它是一种非常高效的字符串匹配算法，有实验统计，它的性能是著名的[KMP 算法](https://zh.wikipedia.org/wiki/%E5%85%8B%E5%8A%AA%E6%96%AF-%E8%8E%AB%E9%87%8C%E6%96%AF-%E6%99%AE%E6%8B%89%E7%89%B9%E7%AE%97%E6%B3%95)的 3 到 4 倍。BM 算法的原理很复杂，比较难懂，学起来会比较烧脑。



##### BM 算法的核心思想

&emsp;&emsp;把模式串和主串的匹配过程，看作模式串在主串中不停地往后滑动。当遇到不匹配的字符时，BF 算法和 RK 算法的做法是，模式串往后滑动一位，然后从模式串的第一个字符开始重新匹配。我举个例子解释一下，你可以看我画的这幅图。

<img src="assert/ThePatternStringSlidesBackA.jpg" alt="模式串往后滑动" style="zoom:50%;" />

&emsp;&emsp;主串中的 c，在模式串中是不存在的，所以，模式串向后滑动的时候，只要 c 与模式串有重合，肯定无法匹配。所以，可以一次性把模式串往后多滑动几位，把模式串移动到 c 的后面。

<img src="assert/ThePatternStringSlidesBackB.jpg" alt="模式串往后滑动" style="zoom:50%;" />

&emsp;&emsp;由现象找规律，你可以思考一下，当遇到不匹配的字符时，有什么固定的规律，可以将模式串往后多滑动几位呢？这样一次性往后滑动好几位，那匹配的效率岂不是就提高了？

&emsp;&emsp;BM 算法，本质上其实就是在寻找这种规律。借助这种规律，在模式串与主串匹配的过程中，当模式串和主串某个字符不匹配的时候，能够跳过一些肯定不会匹配的情况，将模式串往后多滑动几位。



##### BM 算法原理分析

&emsp;&emsp;BM 算法包含两部分，分别是坏字符规则（bad character rule）和好后缀规则（good suffix shift）。

1. 坏字符规则

&emsp;&emsp;BF和RK算法，在匹配的过程中，都是按模式串的下标从小到大的顺序，依次与主串中的字符进行匹配的。这种匹配顺序比较符合的思维习惯，而 BM 算法的匹配顺序比较特别，它是按照模式串下标从大到小的顺序，倒着匹配的。我画了一张图，你可以看下。

<img src="assert/PatternStringMatchOfBM.jpg" alt="BM算法模式串匹配" style="zoom:50%;" />

&emsp;&emsp;从模式串的末尾往前倒着匹配，当发现某个字符没法匹配的时候。把这个没有匹配的字符叫作坏字符（主串中的字符）。

<img src="assert/BadCharacterA.jpg" alt="坏字符" style="zoom:50%;" />

&emsp;&emsp;拿坏字符 c 在模式串中查找，发现模式串中并不存在这个字符，也就是说，字符 c 与模式串中的任何字符都不可能匹配。这个时候，可以将模式串直接往后滑动三位，将模式串滑动到 c 后面的位置，再从模式串的末尾字符开始比较。

<img src="assert/BadCharacterB.jpg" alt="坏字符" style="zoom:50%;" />

&emsp;&emsp;模式串中最后一个字符 d，还是无法跟主串中的 a 匹配，这个时候，还能将模式串往后滑动三位吗？答案是不行的。因为这个时候，坏字符 a 在模式串中是存在的，模式串中下标是 0 的位置也是字符 a。这种情况下，可以将模式串往后滑动两位，让两个 a 上下对齐，然后再从模式串的末尾字符开始，重新匹配。

<img src="assert/BadCharacterC.jpg" alt="坏字符" style="zoom:50%;" />

&emsp;&emsp;第一次不匹配的时候，滑动了三位，第二次不匹配的时候，将模式串后移两位，那具体滑动多少位，到底有没有规律呢？

&emsp;&emsp;当发生不匹配的时候，把坏字符对应的模式串中的字符下标记作 si。如果坏字符在模式串中存在，把这个坏字符在模式串中的下标记作 xi。如果不存在，把 xi 记作 -1。那模式串往后移动的位数就等于 si-xi。（注意，我这里说的下标，都是字符在模式串的下标）。

<img src="assert/BadCharacterD.jpg" alt="坏字符" style="zoom:50%;" />

&emsp;&emsp;这里要特别说明一点，如果坏字符在模式串里多处出现，那在计算 xi 的时候，选择最靠后的那个，因为这样不会让模式串滑动过多，导致本来可能匹配的情况被滑动略过。

&emsp;&emsp;利用坏字符规则，BM 算法在最好情况下的时间复杂度非常低，是 O(n/m)。比如，主串是 aaabaaabaaabaaab，模式串是 aaaa。每次比对，模式串都可以直接后移四位，所以，匹配具有类似特点的模式串和主串的时候，BM 算法非常高效。

&emsp;&emsp;不过，单纯使用坏字符规则还是不够的。因为根据 si-xi 计算出来的移动位数，有可能是负数，比如主串是 aaaaaaaaaaaaaaaa，模式串是 baaa。不但不会向后滑动模式串，还有可能倒退。所以，BM 算法还需要用到“好后缀规则”。

2. 好后缀规则
&emsp;&emsp;好后缀规则实际上跟坏字符规则的思路很类似。你看我下面这幅图。当模式串滑动到图中的位置的时候，模式串和主串有 2 个字符是匹配的，倒数第 3 个字符发生了不匹配的情况。

<img src="assert/GoodSuffixShiftA.jpg" alt="好后缀规则" style="zoom:50%;" />

&emsp;&emsp;这个时候该如何滑动模式串呢？当然，还可以利用坏字符规则来计算模式串的滑动位数，不过，也可以使用好后缀处理规则。

&emsp;&emsp;把已经匹配的 bc 叫作好后缀，记作{u}。拿它在模式串中查找，如果找到了另一个跟{u}相匹配的子串{u*}，那就将模式串滑动到子串{u*}与主串中{u}对齐的位置。

<img src="assert/GoodSuffixShiftB.jpg" alt="好后缀规则" style="zoom:50%;" />

&emsp;&emsp;如果在模式串中找不到另一个等于{u}的子串，就直接将模式串，滑动到主串中{u}的后面，因为之前的任何一次往后滑动，都没有匹配主串中{u}的情况。

<img src="assert/GoodSuffixShiftC.jpg" alt="好后缀规则" style="zoom:50%;" />

&emsp;&emsp;不过，当模式串中不存在等于{u}的子串时，直接将模式串滑动到主串{u}的后面。这样做是否有点太过头呢？来看下面这个例子。这里面 bc 是好后缀，尽管在模式串中没有另外一个相匹配的子串{u*}，但是如果将模式串移动到好后缀的后面，如图所示，那就会错过模式串和主串可以匹配的情况。

<img src="assert/GoodSuffixShiftD.jpg" alt="好后缀规则" style="zoom:50%;" />

&emsp;&emsp;如果好后缀在模式串中不存在可匹配的子串，那在一步一步往后滑动模式串的过程中，只要主串中的{u}与模式串有重合，那肯定就无法完全匹配。但是当模式串滑动到前缀与主串中{u}的后缀有部分重合的时候，并且重合的部分相等的时候，就有可能会存在完全匹配的情况。

<img src="assert/GoodSuffixShiftE.jpg" alt="好后缀规则" style="zoom:50%;" />

&emsp;&emsp;所以，针对这种情况，不仅要看好后缀在模式串中，是否有另一个匹配的子串，还要考察好后缀的后缀子串，是否存在跟模式串的前缀子串匹配的。

&emsp;&emsp;所谓某个字符串 s 的后缀子串，就是最后一个字符跟 s 对齐的子串，比如 abc 的后缀子串就包括 c, bc。所谓前缀子串，就是起始字符跟 s 对齐的子串，比如 abc 的前缀子串有 a，ab。从好后缀的后缀子串中，找一个最长的并且能跟模式串的前缀子串匹配的，假设是{v}，然后将模式串滑动到如图所示的位置。

<img src="assert/GoodSuffixShiftE.jpg" alt="好后缀规则" style="zoom:50%;" />

&emsp;&emsp;当模式串和主串中的某个字符不匹配的时候，如何选择用好后缀规则还是坏字符规则，来计算模式串往后滑动的位数？

&emsp;&emsp;可以分别计算好后缀和坏字符往后滑动的位数，然后取两个数中最大的，作为模式串往后滑动的位数。这种处理方法还可以避免前面提到的，根据坏字符规则，计算得到的往后滑动的位数，有可能是负数的情况。



##### BM 算法代码实现

&emsp;&emsp;“坏字符规则”本身不难理解。当遇到坏字符时，要计算往后移动的位数 si-xi，其中 xi 的计算是重点，如何求得 xi 呢？或者说，如何查找坏字符在模式串中出现的位置呢？

&emsp;&emsp;如果拿坏字符，在模式串中顺序遍历查找，这样就会比较低效，势必影响这个算法的性能。有没有更加高效的方式呢？之前学的散列表，这里可以派上用场了。可以将模式串中的每个字符及其下标都存到散列表中。这样就可以快速找到坏字符在模式串的位置下标了。

&emsp;&emsp;关于这个散列表，只实现一种最简单的情况，假设字符串的字符集不是很大，每个字符长度是 1 字节，用大小为 256 的数组，来记录每个字符在模式串中出现的位置。数组的下标对应字符的 ASCII 码值，数组中存储这个字符在模式串中出现的位置。

<img src="assert/BM.jpg" alt="BM算法的存储" style="zoom:50%;" />

&emsp;&emsp;，变量 b 是模式串，m 是模式串的长度，bc 表示刚刚讲的散列表。

```Java
private static final int SIZE = 256; // 全局变量或成员变量
private void generateBC(char[] b, int m, int[] bc) {
  for (int i = 0; i < SIZE; ++i) {
    bc[i] = -1; // 初始化 bc
  }
  for (int i = 0; i < m; ++i) {
    int ascii = (int)b[i]; // 计算 b[i] 的 ASCII 值
    bc[ascii] = i;
  }

}
```
&emsp;&emsp;掌握了坏字符规则之后，先把 BM 算法代码的大框架写好，先不考虑好后缀规则，仅用坏字符规则，并且不考虑 si-xi 计算得到的移动位数可能会出现负数的情况。

```Java
public int bm(char[] a, int n, char[] b, int m) {
  int[] bc = new int[SIZE]; // 记录模式串中每个字符最后出现的位置
  generateBC(b, m, bc); // 构建坏字符哈希表
  int i = 0; // i 表示主串与模式串对齐的第一个字符
  while (i <= n - m) {
    int j;
    for (j = m - 1; j >= 0; --j) { // 模式串从后往前匹配
      if (a[i+j] != b[j]) break; // 坏字符对应模式串中的下标是 j
    }
    if (j < 0) {
      return i; // 匹配成功，返回主串与模式串第一个匹配的字符的位置
    }
    // 这里等同于将模式串往后滑动 j-bc[(int)a[i+j]] 位
    i = i + (j - bc[(int)a[i+j]]); 
  }
  return -1;
}
```
&emsp;&emsp;代码里的注释已经很详细了，我就不再赘述了。不过，为了你方便理解，我画了一张图，将其中的一些关键变量标注在上面了，结合着图，代码应该更好理解。

<img src="assert/BMCode.jpg" alt="BM算法关键变量" style="zoom:50%;" />

&emsp;&emsp;已经实现了包含坏字符规则的框架代码，只剩下往框架代码中填充好后缀规则了。现在，就来看看，如何实现好后缀规则。它的实现要比坏字符规则复杂一些。

&emsp;&emsp;好后缀的处理规则中最核心的内容：

* 在模式串中，查找跟好后缀匹配的另一个子串；

* 在好后缀的后缀子串中，查找最长的、能跟模式串前缀子串匹配的后缀子串；

&emsp;&emsp;在不考虑效率的情况下，这两个操作都可以用很“暴力”的匹配查找方式解决。但是，如果想要 BM 算法的效率很高，这部分就不能太低效。如何来做呢？

&emsp;&emsp;因为好后缀也是模式串本身的后缀子串，所以，可以在模式串和主串正式匹配之前，通过预处理模式串，预先计算好模式串的每个后缀子串，对应的另一个可匹配子串的位置。这个预处理过程比较有技巧，很不好懂，应该是这节最难懂的内容了。

&emsp;&emsp;如何表示模式串中不同的后缀子串呢？因为后缀子串的最后一个字符的位置是固定的，下标为 m-1，只需要记录长度就可以了。通过长度，可以确定一个唯一的后缀子串。

<img src="assert/SubStringOfPatternStringA.jpg" alt="模式串中的后缀子串" style="zoom:50%;" />

&emsp;&emsp;现在，要引入最关键的变量 suffix 数组。suffix 数组的下标 k，表示后缀子串的长度，下标对应的数组值存储的是，在模式串中跟好后缀{u}相匹配的子串{u*}的起始下标值。

<img src="assert/SubStringOfPatternStringB.jpg" alt="模式串中的后缀子串" style="zoom:50%;" />

&emsp;&emsp;但是，如果模式串中有多个（大于 1 个）子串跟后缀子串{u}匹配，那 suffix 数组中该存储哪一个子串的起始位置呢？为了避免模式串往后滑动得过头了，肯定要存储模式串中最靠后的那个子串的起始位置，也就是下标最大的那个子串的起始位置。不过，这样处理就足够了吗？

&emsp;&emsp;实际上，仅仅是选最靠后的子串片段来存储是不够的。

&emsp;&emsp;不仅要在模式串中，查找跟好后缀匹配的另一个子串，还要在好后缀的后缀子串中，查找最长的能跟模式串前缀子串匹配的后缀子串。

&emsp;&emsp;如果只记录刚刚定义的 suffix，实际上，只能处理规则的前半部分，也就是，在模式串中，查找跟好后缀匹配的另一个子串。所以，除了 suffix 数组之外，还需要另外一个 boolean 类型的 prefix 数组，来记录模式串的后缀子串是否能匹配模式串的前缀子串。

<img src="assert/SubStringOfPatternStringC.jpg" alt="模式串中的后缀子串" style="zoom:50%;" />

&emsp;&emsp;现在，来看下，如何来计算并填充这两个数组的值？这个计算过程非常巧妙。

&emsp;&emsp;拿下标从 0 到 i 的子串（i 可以是 0 到 m-2）与整个模式串，求公共后缀子串。如果公共后缀子串的长度是 k，那就记录 suffix[k]=j（j 表示公共后缀子串的起始下标）。如果 j 等于 0，也就是说，公共后缀子串也是模式串的前缀子串，就记录 prefix[k]=true。

<img src="assert/SubStringOfPatternStringD.jpg" alt="模式串中的后缀子串" style="zoom:50%;" />

&emsp;&emsp;把 suffix 数组和 prefix 数组的计算过程，用代码实现出来，就是下面这个样子：

```Java
// b 表示模式串，m 表示长度，suffix，prefix 数组事先申请好了
private void generateGS(char[] b, int m, int[] suffix, boolean[] prefix) {
  for (int i = 0; i < m; ++i) { // 初始化
    suffix[i] = -1;
    prefix[i] = false;
  }
  for (int i = 0; i < m - 1; ++i) { // b[0, i]
    int j = i;
    int k = 0; // 公共后缀子串长度
    while (j >= 0 && b[j] == b[m-1-k]) { // 与 b[0, m-1] 求公共后缀子串
      --j;
      ++k;
      suffix[k] = j+1; //j+1 表示公共后缀子串在 b[0, i] 中的起始下标
    }
    i
    if (j == -1) prefix[k] = true; // 如果公共后缀子串也是模式串的前缀子串
  }
}
```
&emsp;&emsp;有了这两个数组之后，现在来看，在模式串跟主串匹配的过程中，遇到不能匹配的字符时，如何根据好后缀规则，计算模式串往后滑动的位数？

&emsp;&emsp;假设好后缀的长度是 k。先拿好后缀，在 suffix 数组中查找其匹配的子串。如果 suffix[k] 不等于 -1（-1 表示不存在匹配的子串），那就将模式串往后移动 j-suffix[k]+1 位（j 表示坏字符对应的模式串中的字符下标）。如果 suffix[k] 等于 -1，表示模式串中不存在另一个跟好后缀匹配的子串片段。可以用下面这条规则来处理。

<img src="assert/PatternStringMoveA.jpg" alt="模式串的移动" style="zoom:50%;" />

&emsp;&emsp;好后缀的后缀子串 b[r, m-1]（其中，r 取值从 j+2 到 m-1）的长度 k=m-r，如果 prefix[k] 等于 true，表示长度为 k 的后缀子串，有可匹配的前缀子串，这样可以把模式串后移 r 位。

<img src="assert/PatternStringMoveB.jpg" alt="模式串的移动" style="zoom:50%;" />

&emsp;&emsp;如果两条规则都没有找到可以匹配好后缀及其后缀子串的子串，就将整个模式串后移 m 位。

![模式串的移动](assert/PatternStringMoveC.jpg)

&emsp;&emsp;至此，好后缀规则的代码实现也讲完了。把好后缀规则加到前面的代码框架里，就可以得到 BM 算法的完整版代码实现。

```Java
// a,b 表示主串和模式串；n，m 表示主串和模式串的长度。
public int bm(char[] a, int n, char[] b, int m) {
  int[] bc = new int[SIZE]; // 记录模式串中每个字符最后出现的位置
  generateBC(b, m, bc); // 构建坏字符哈希表
  int[] suffix = new int[m];
  boolean[] prefix = new boolean[m];
  generateGS(b, m, suffix, prefix);
  int i = 0; // j 表示主串与模式串匹配的第一个字符
  while (i <= n - m) {
    int j;
    for (j = m - 1; j >= 0; --j) { // 模式串从后往前匹配
      if (a[i+j] != b[j]) break; // 坏字符对应模式串中的下标是 j
    }
    if (j < 0) {
      return i; // 匹配成功，返回主串与模式串第一个匹配的字符的位置
    }
    int x = j - bc[(int)a[i+j]];
    int y = 0;
    if (j < m-1) { // 如果有好后缀的话
      y = moveByGS(j, m, suffix, prefix);
    }
    i = i + Math.max(x, y);
  }
  return -1;
}
 
// j 表示坏字符对应的模式串中的字符下标 ; m 表示模式串长度
private int moveByGS(int j, int m, int[] suffix, boolean[] prefix) {
  int k = m - 1 - j; // 好后缀长度
  if (suffix[k] != -1) return j - suffix[k] +1;
  for (int r = j+2; r <= m-1; ++r) {
    if (prefix[m-r] == true) {
      return r;
    }
  }
  return m;
}
```



##### BM 算法的性能分析及优化

&emsp;&emsp;先来分析 BM 算法的内存消耗。整个算法用到了额外的 3 个数组，其中 bc 数组的大小跟字符集大小有关，suffix 数组和 prefix 数组的大小跟模式串长度 m 有关。

&emsp;&emsp;如果处理字符集很大的字符串匹配问题，bc 数组对内存的消耗就会比较多。因为好后缀和坏字符规则是独立的，如果运行的环境对内存要求苛刻，可以只使用好后缀规则，不使用坏字符规则，这样就可以避免 bc 数组过多的内存消耗。不过，单纯使用好后缀规则的 BM 算法效率就会下降一些了。

&emsp;&emsp;对于执行效率来说，可以先从时间复杂度的角度来分析。

&emsp;&emsp;实际上，我前面讲的 BM 算法是个初级版本。为了让你能更容易理解，有些复杂的优化我没有讲。基于我目前讲的这个版本，在极端情况下，预处理计算 suffix 数组、prefix 数组的性能会比较差。

&emsp;&emsp;比如模式串是 aaaaaaa 这种包含很多重复的字符的模式串，预处理的时间复杂度就是 O(m^2)。当然，大部分情况下，时间复杂度不会这么差。关于如何优化这种极端情况下的时间复杂度退化，如果感兴趣，你可以自己研究一下。

&emsp;&emsp;实际上，BM 算法的时间复杂度分析起来是非常复杂，这篇论文[“A new proof of the linearity of the Boyer-Moore string searching algorithm"](https://dl.acm.org/doi/10.1109/SFCS.1977.3)证明了在最坏情况下，BM 算法的比较次数上限是 5n。这篇论文[“Tight bounds on the complexity of the Boyer-Moore string matching algorithm”](https://dl.acm.org/doi/10.5555/127787.127830)证明了在最坏情况下，BM 算法的比较次数上限是 3n。



##### 解答开篇 & 内容小结

&emsp;&emsp;今天，讲了一种比较复杂的字符串匹配算法，BM 算法。尽管复杂、难懂，但匹配的效率却很高，在实际的软件开发中，特别是一些文本编辑器中，应用比较多。

&emsp;&emsp;BM 算法核心思想是，利用模式串本身的特点，在模式串中某个字符与主串不能匹配的时候，将模式串往后多滑动几位，以此来减少不必要的字符比较，提高匹配的效率。BM 算法构建的规则有两类，坏字符规则和好后缀规则。好后缀规则可以独立于坏字符规则使用。因为坏字符规则的实现比较耗内存，为了节省内存，可以只用好后缀规则来实现 BM 算法。



##### 课后思考

&emsp;&emsp;你熟悉的编程语言中的查找函数，或者工具、软件中的查找功能，都是用了哪种字符串匹配算法呢？





BM 算法分析着实比较复杂，不过按照老师的思路，一步一步走，看懂应该没问题的。但其实有些代码实现细节看不懂关系也不大。学算法主要目的是学习算法的思想，能在需要的时候加以应用就好。
但对于平时工作，几乎不可能遇到，需要自己手写一个字符串匹配算法的场景。那还要学，图的是什么？
我认为文章中值得学习借鉴的思想有：
1、要有优化意识，前面的 BF，RK 算法已经能够满足需求了，为什么发明 BM 算法？是为了减少时间复杂度，但是带来的弊端是，优化代码变得复杂，维护成本变高。
2、需要查找，需要减少时间复杂度，应该想到什么？散列表。
3、如果某个表达式计算开销比较大，又需要频繁的使用怎么办？预处理，并缓存。
作者回复: 👍





我对这次课的内容一知半解，于是在网上搜到一个文档，里面的图挺好的，跟大家分享一下：http://www.cs.jhu.edu/~langmea/resources/lecture_notes/boyer_moore.pd





大体思路应该是看懂了，不过具体实现和代码细节还需要时间消化。BM算法的核心思想是通过将模式串沿着主串大踏步的向后滑动，从而大大减少比较次数，降低时间复杂度。而算法的关键在于如何兼顾步子迈得足够大与无遗漏，同时要尽量提高执行效率。这就需要模式串在向后滑动时，遵守坏字符规则与好后缀规则，同时采用一些技巧。
坏字符规则：从后往前逐位比较模式串与主串的字符，当找到不匹配的坏字符时，记录模式串的下标值si，并找到坏字符在模式串中，位于下标si前的最近位置xi（若无则记为-1），si-xi即为向后滑动距离。（PS：我觉得加上xi必须在si前面，也就是比si小的条件，就不用担心计算出的距离为负了）。但是坏字符规则向后滑动的步幅还不够大，于是需要好后缀规则。
好后缀规则：从后往前逐位比较模式串与主串的字符，当出现坏字符时停止。若存在已匹配成功的子串｛u｝，那么在模式串的｛u｝前面找到最近的｛u｝，记作｛u'｝。再将模式串后移，使得模式串的｛u'｝与主串的｛u｝重叠。若不存在｛u'｝，则直接把模式串移到主串的｛u｝后面。为了没有遗漏，需要找到最长的、能够跟模式串的前缀子串匹配的，好后缀的后缀子串（同时也是模式串的后缀子串）。然后把模式串向右移到其左边界，与这个好后缀的后缀子串在主串中的左边界对齐。
何时使用坏字符规则和好后缀规则呢？首先在每次匹配过程中，一旦发现坏字符，先执行坏字符规则，如果发现存在好后缀，还要执行好后缀规则，并从两者中选择后移距离最大的方案执行。
技巧：
1.通过散列表实现，坏字符在模式串中下标位置的快速查询。
2.每次执行好后缀原则时，都会计算多次能够与模式串前缀子串相匹配的好后缀的最长后缀子串。为了提高效率，可以预先计算模式串的所有后缀子串，在模式串中与之匹配的另一个子串的位置。同时预计算模式串中（同长度的）后缀子串与前缀子串是否匹配并记录。在具体操作中直接使用，大大提高效率。
3.如何快速记录模式串后缀子串匹配的另一个子串位置，以及模式串（相同长度）前缀与后缀子串石否匹配呢？先用一个suffix数组，下标值k为后缀子串的长度，从模式串下标为i（0~m-2）的字符为最后一个字符，查找这个子串是否与后缀子串匹配，若匹配则将子串起始位置的下标值j赋给suffix[k]。若j为0，说明这个匹配子串的起始位置为模式串的起始位置，则用一个数组prefix，将prefix[k]设为true，否则设为false。k从0到m（模式串的长度）于是就得到了模式串所有前缀与后缀子串的匹配情况。





这篇文章啃了很长时间了，有个问题请教：是否可以不要prefix数组，直接通过suffix[k]==0来判断前缀子串的匹配与否？








曾经一度觉得字符串匹配的几大算法，都是高山仰止的，难以理解。
但是前阵子受两句话启发，从此以后对字符串匹配问题，至少在战略层面藐视了它：
1. 善用之前信息(从信息论的角度：消除信息的不确定性，就是引入信息)
2. 增加效率，在资源有限的情况下，只有想办法少做事情







好后缀原则下，最后一种情况为什么移到坏字符后面呢，不能移到好后缀的后面吗？即m+1,而不是j + 1
作者回复: 你说的对 👍 我改下







老师好！今天讲的BM算法确实有点复杂，不过听的时候有熟悉的感觉，似乎跟之前接触过的Boyer Moore算法很像，查了一下才发现原来是同一种算法😂
在工作中遇到过这样的情况，需要在一个长度为n (比如十亿级)的巨大的主串中查找长度为m(比如几百)的模式串。主串是固定的，从直观上讲，要加快搜索速度，就需要对主串建索引。BWT-FM算法是解决这类问题最经典的算法，刚接触时也是不好理解，但感觉非常神奇，可以将搜索的时间复杂度降到O(m)，是我认为最伟大的算法之一。





generateGS函数里suffix和prefix的赋值应该放到while循环内，即每次k变动时都要赋值。
另外请问下：好后缀的后缀子串 b[r, m-1]，这里的r的初值j+2是怎么得来的啊？
作者回复: j表示坏字符的下标 好狗追其实下标j+1





跟课程以来觉得最难的一次，也有可能之前使用手机看的原因。总体上，拿手机看了3次，今天在电脑上看了第一次，终于将好后缀那部分理解清晰。学生时代接触的性能较高字符串匹配算法就是KMP，个人感觉BM比KMP更难理解，大家如果有没理解的，还是要多多看，或者拿着笔画一画





在计算suffix 数组和 prefix 数组的代码中，第15行的i是不是多余的诶~？






在用一个256的数组 用字符的ascii码做下标 记录该字符出现的位置 如果存在相同字符怎么办呢？之前的会被新的覆盖掉的把！
作者回复: 是的 就是要覆盖掉 留最大的





好后缀原则中，最后一种情况，应该是移动 m 位吧，移动整个模式串的长度。
作者回复: 是的





老师，suffix和prefix的赋值那里有BUG，应该在每一次k的变动都要有suffix赋值。
作者回复: 是的 多谢





好后缀原则中，最后一种情况，为什么是移动j + 1 位，而不是m+1位
作者回复: 移动到坏字符后面 移动m+1位是怎么理解的呢





。。。我知道为什么老师说 si-xi 可能是负数了。
虽然理论上应该是从 si 的位置往前找 xi。但代码实现为了提高效率，使用了哈希表，记录的是不同字符在模式串中“最后出现的位置”，并不是 si 的位置往前查找的第一个位置，所以确实会出现 xi 大于 si 的情况，原来如此原来如此。。。





generateGS code第15行 没有写完吗？





高票那个留言，是移动m位，不是m+1位。
这节课细节上小问题有点多，不过瑕不掩瑜，思想重要，细节自己钻研。
作者回复: 是的






讲shuffix的第一个图中shuffix[4] = -1，这个-1怎么来的，不能理解，能不能再讲一下