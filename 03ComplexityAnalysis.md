复杂度分析（上）：如何分析、统计算法的执行效率和资源消耗？
===


&emsp;&emsp;数据结构和算法本身解决的是“快”和“省”的问题，即如何让代码运行得更快，如何让代码更省存储空间。用时间和空间复杂度来衡量算法代码的执行效率。



### 为什么需要复杂度分析？

&emsp;&emsp;通过统计、监控，就能得到算法执行的时间和占用的内存大小。这种分析方法叫事后统计法。

&emsp;&emsp;事后统计法的局限性。

1. 测试结果非常依赖测试环境，测试环境不同的硬件对测试结果有很大的影响

2. 测试结果受数据规模、待排序数据的有序度的影响很大。极端情况下，如果数据已经是有序的，那排序算法不需要做任何操作，执行时间就会非常短。如果测试数据规模太小，测试结果可能无法真实地反应算法的性能。



#### 大 O 复杂度表示法

&emsp;&emsp;从 CPU 的角度来看，代码的每一行都执行着类似的操作：读数据-运算-写数据。尽管每行代码对应的 CPU 执行的个数、执行的时间都不一样，粗略估计时，可以假设每行代码执行的时间都一样，为 unit_time。

&emsp;&emsp;代码的执行时间 T(n) 与每行代码的执行次数 n 成正比。

&emsp;&emsp;大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以，也叫作渐进时间复杂度（asymptotic time complexity），简称时间复杂度。

&emsp;&emsp;当 n 很大时，低阶、常量、系数三部分并不左右增长趋势，所以都可以忽略。只需要记录一个最大量级就可以了。

#### 时间复杂度分析

1）单段代码看高频：比如循环。
2）多段代码取最大：比如一段代码中有单循环和多重循环，那么取多重循环的复杂度。
3）嵌套代码求乘积：比如递归、多重循环等
4）多个规模求加法：比如方法有两个参数控制两个循环的次数，那么这时就取二者复杂度相加。



#### 几种常见时间复杂度实例分析

![复杂度量级](assert/Complexity.jpg)

&emsp;&emsp;常见的复杂度量级，可以粗略地分为，多项式量级和非多项式量级。其中，非多项式量级只有两个：O(2^n^) 和 O(n!)。

&emsp;&emsp;当数据规模 n 越来越大时，非多项式量级(NP问题,非确定多项式问题)算法的执行时间会急剧增加，求解问题的执行时间会无限增长。所以，非多项式时间复杂度的算法其实是非常低效的算法。

1. O(1)

&emsp;&emsp;O(1) 只是常量级时间复杂度的一种表示方法，并不是指只执行了一行代码。只要代码的执行时间不随 n 的增大而增长，这样代码的时间复杂度都记作 O(1)。一般情况下，只要算法中不存在循环语句、递归语句，其时间复杂度也是Ο(1)。
2. O($logn$)、O(n$logn$)

&emsp;&emsp;对数阶时间复杂度非常常见，同时也是最难分析的一种时间复杂度。对数之间是可以互相转换的，在对数阶时间复杂度的表示方法里，忽略对数的“底”，统一表示为 O($logn$)。归并排序、快速排序的时间复杂度都是 O(n$logn$)。

3. O(m+n)、O(m*n)

&emsp;&emsp;代码的复杂度由两个数据的规模来决定。无法事先评估 m 和 n 的量级大小，所以时间复杂度就是 O(m+n)。



#### 空间复杂度分析

&emsp;&emsp;空间复杂度全称就是渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系。

&emsp;&emsp;常见的空间复杂度就是 O(1)、O(n)、O(n^2^ )，像 O($logn$)、O(n$logn$) 这样的对数阶复杂度平时都用不到。空间复杂度分析比时间复杂度分析要简单很多。



### 内容小结

&emsp;&emsp;复杂度也叫渐进复杂度，包括时间复杂度和空间复杂度，用来分析算法执行效率与数据规模之间的增长关系，可以粗略地表示，越高阶复杂度的算法，执行效率越低。常见的复杂度并不多，从低阶到高阶有：O(1)、O($logn$)、O(n)、O(n$logn$)、O(n^2^ )。

![常见的复杂度](assert/ComplexityFunction.jpg)



### 课后思考

&emsp;&emsp;有人说，项目之前都会进行性能测试，再做代码的时间复杂度、空间复杂度分析，是不是多此一举呢？而且，每段代码都分析一下时间复杂度、空间复杂度，是不是很浪费时间呢？你怎么看待这个问题呢？

&emsp;&emsp;性能测试只是事后测试法，存在局限性。测试环境的硬件会影响测试结果，测试数据的规模和有序度等会导致测试结果不一样。复杂度分析会对算法的执行效率和空间占用给出定性结论。结合复杂度分析和实际业务场景会使算法的结果更优秀，出现不一致问题的时候有定位的理论依据。



渐进时间，空间复杂度分析为提供了一个很好的理论分析的方向，并且它是宿主平台无关的，能够对程序或算法有一个大致的认识，。
复杂度分析只是一个理论模型，只能提供给粗略的估计分析，进行一定的性能基准测试是很有必要的，比如横向基准测试等。
渐进式时间，空间复杂度分析与性能基准测试并不冲突，而是相辅相成的。一个低阶的时间复杂度程序有极大的可能性会优于一个高阶的时间复杂度程序，在实际编程中，时刻关心理论时间，空间度模型是有助于产出效率高的程序的。复杂度分析只是提供一个粗略的分析模型，不会浪费太多时间，重点在于在编程时，要具有这种复杂度分析的思维。